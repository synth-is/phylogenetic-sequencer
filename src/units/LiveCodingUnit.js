import { UNIT_TYPES } from '../constants';
import { BaseUnit } from './BaseUnit';
import SoundRenderer from '../utils/SoundRenderer';

// ---------------------------------------------------------------------------
// Short Unit ID Helper
// Provides stable, compact aliases (u1, u2, ...) for verbose internal ids.
// These are used to build shorter sample names (u1_s0) instead of
// the previous verbose pattern (unit<id>_evo_<n>). Mapping is kept
// module-local; not exported to avoid accidental external coupling.
// ---------------------------------------------------------------------------
const _unitAliasMap = new Map();
function getShortUnitId(originalId) {
  if (_unitAliasMap.has(originalId)) return _unitAliasMap.get(originalId);
  const alias = 'u' + (_unitAliasMap.size + 1);
  _unitAliasMap.set(originalId, alias);
  return alias;
}

export class LiveCodingUnit extends BaseUnit {
  constructor(id) {
    super(id, UNIT_TYPES.LIVE_CODING);
    
    // Assign a short, human-friendly unit alias (u1, u2, ...)
    // Global maps (module scope) ensure stable aliases across instances
    if (typeof getShortUnitId === 'function') {
      this.shortUnitId = getShortUnitId(id);
    } else {
      // Fallback in unlikely case helper not defined yet
      this.shortUnitId = 'u' + id;
    }

    // Strudel REPL instance (will be set when editor is ready)
    this.replInstance = null;
    this.editorInstance = null;
    
    // Sample bank management
    this.sampleBank = new Map(); // genomeId -> { name, blobUrl, metadata }
    this.sampleCounter = 0; // For generating unique sample names
    this.pendingSamples = {}; // Unit-specific pending samples (avoid global pollution)
    this.hasPendingSamples = false;
    this.pendingCode = null; // Store code updates when REPL is not ready
    
    // Code generation settings
    this.autoGenerateCode = true;
    this.preserveManualEdits = true; // Preserve manual edits when adding new samples
    this.maxSamplesInPattern = 4; // Maximum number of samples to include in auto-generated patterns
    this.sampleMultiplier = 1; // How many times each hovered sound should be added to the pattern
    this.basePattern = `// Live coding unit ${this.id}\n// Waiting for evolutionary sounds...\n// Double-click sounds in the tree to add them here`; // Unit-specific default pattern
    this.currentCode = this.basePattern;
    this.lastAutoGeneratedCode = null; // Track what we last auto-generated to detect manual edits
    
    // Sync/solo attributes (like in StrudelReplTest)
    this.sync = true;
    this.solo = false;
    
    // Playback state
    this.isPlaying = false;
    
    // Audio buffer to blob URL conversion cache
    this.blobUrlCache = new Map(); // genomeId-params -> blobUrl
    
    // Callback for when code changes (to notify editor)
    this.onCodeChange = null;
    
    // Queue for sync/solo updates when element not yet attached
    this._pendingUiFlags = {};
    
    console.log(`LiveCodingUnit ${this.id} initialized`);
  }

  // Wait until REPL context is fully ready (context + samples function)
  async _waitForReplReady(timeoutMs = 2000, intervalMs = 40) {
    const start = Date.now();
    console.log(`LiveCodingUnit ${this.id}: Waiting for REPL context to be ready...`);
    
    while (Date.now() - start < timeoutMs) {
      // More thorough context readiness check
      const hasInstance = !!this.replInstance;
      const hasContext = !!this.replInstance?.context;
      const hasSamplesFunction = typeof this.replInstance?.context?.samples === 'function';
      const hasValidContext = hasContext && this.replInstance.context !== undefined;
      
      // TEMPORARILY DISABLED: console.log(`LiveCodingUnit ${this.id}: REPL readiness check:`, {
      //   hasInstance,
      //   hasContext,
      //   hasSamplesFunction,
      //   hasValidContext,
      //   contextType: typeof this.replInstance?.context,
      //   elapsed: Date.now() - start
      // });
      
      if (hasInstance && hasValidContext && hasSamplesFunction) {
        console.log(`LiveCodingUnit ${this.id}: REPL context ready after ${Date.now() - start}ms`);
        return true;
      }
      
      await new Promise(r => setTimeout(r, intervalMs));
    }
    
    console.warn(`LiveCodingUnit ${this.id}: REPL context not ready after ${timeoutMs}ms`);
    return !!(this.replInstance?.context);
  }

  async initialize() {
    try {
      console.log(`Initializing LiveCodingUnit ${this.id}`);
      await super.initialize();
      
      // Register this unit globally for coordination
      this._registerGlobally();
      
      console.log(`LiveCodingUnit ${this.id} initialized successfully`);
      return true;
    } catch (err) {
      console.error(`LiveCodingUnit ${this.id} initialization error:`, err);
      return false;
    }
  }

  /**
   * Register this unit in global registry for coordination
   */
  _registerGlobally() {
    if (!window._liveCodingUnits) {
      window._liveCodingUnits = new Map();
    }
    window._liveCodingUnits.set(this.id, this);
    console.log(`LiveCodingUnit ${this.id}: Registered globally. Total units: ${window._liveCodingUnits.size}`);
  }

  /**
   * Unregister this unit from global registry
   */
  _unregisterGlobally() {
    if (window._liveCodingUnits) {
      window._liveCodingUnits.delete(this.id);
      console.log(`LiveCodingUnit ${this.id}: Unregistered globally. Remaining units: ${window._liveCodingUnits.size}`);
    }
  }

  /**
   * Connect this unit to a REPL instance (simplified for single REPL system)
   * Now supports both immediate connection (element only) and full connection (editor + element)
   */
  async setReplInstance(editor, strudelElement = null) {
    console.log(`LiveCodingUnit ${this.id}: setReplInstance called`, {
      hasEditor: !!editor,
      hasStrudelElement: !!strudelElement,
      editorHasRepl: !!editor?.repl,
      isElementOnly: !editor?.repl && !!editor // Just the element reference
    });
    
    // Store previous element for change detection
    const prevElement = this.strudelElement;
    const elementChanged = prevElement && strudelElement && prevElement !== strudelElement;

    // Handle both immediate (element only) and full (editor) connections
    if (editor?.repl) {
      // Full connection with actual editor instance
      this.replInstance = editor.repl;
      this.editorInstance = editor;
    } else {
      // Immediate connection with just the element (for showing "Ready" status)
      this.replInstance = editor; // The element itself acts as a placeholder
      this.editorInstance = null; // Will be set later when full editor is ready
    }
    
    this.strudelElement = strudelElement || editor;

    console.log(`LiveCodingUnit ${this.id}: REPL instance connected`, {
      hasReplInstance: !!this.replInstance,
      hasEditorInstance: !!this.editorInstance,
      hasStrudelElement: !!this.strudelElement,
      connectionType: editor?.repl ? 'full' : 'immediate',
      elementChanged
    });

    // Apply any pending sync/solo flags
    try {
      if (this.strudelElement && this._pendingUiFlags) {
        if (this._pendingUiFlags.sync !== undefined) {
          this.strudelElement.sync = this._pendingUiFlags.sync;
          console.log(`LiveCodingUnit ${this.id}: Applied pending sync:`, this._pendingUiFlags.sync);
        }
        if (this._pendingUiFlags.solo !== undefined) {
          this.strudelElement.solo = this._pendingUiFlags.solo;
          console.log(`LiveCodingUnit ${this.id}: Applied pending solo:`, this._pendingUiFlags.solo);
        }
        this._pendingUiFlags = {};
      }
    } catch (err) {
      console.warn(`LiveCodingUnit ${this.id}: Error applying UI flags:`, err);
    }

    // Set up code persistence listeners (avoid duplicates)
    if (this.strudelElement) {
      // Remove existing listeners
      if (this._blurListener) {
        this.strudelElement.removeEventListener('blur', this._blurListener);
      }
      if (this._inputListener) {
        this.strudelElement.removeEventListener('input', this._inputListener);
      }
      
      // Create new listeners
      this._blurListener = () => this.persistCurrentCode();
      this._inputListener = () => {
        clearTimeout(this._persistTimeout);
        this._persistTimeout = setTimeout(() => this.persistCurrentCode(), 1000);
      };
      
      // Add listeners
      this.strudelElement.addEventListener('blur', this._blurListener);
      this.strudelElement.addEventListener('input', this._inputListener);
      
      console.log(`LiveCodingUnit ${this.id}: Code persistence listeners attached`);
    }


    // Process pending items and restore state when REPL is FULLY ready (not just immediate)
    if (this.replInstance && this.editorInstance && editor?.repl) {
      console.log(`LiveCodingUnit ${this.id}: Full REPL ready - processing pending items`);
      
      try {
        // Restore persisted code when switching back to this unit
        if (this.currentCode && this.currentCode !== this.basePattern) {
          console.log(`LiveCodingUnit ${this.id}: Restoring persisted code`);
          this.editorInstance.setCode(this.currentCode);
          this.strudelElement?.setAttribute('code', this.currentCode);
          
          // CRITICAL: Re-evaluate to restore visual feedback (Mini Notation highlighting)
          console.log(`LiveCodingUnit ${this.id}: Re-evaluating code to restore visual feedback`);
          setTimeout(async () => {
            try {
              await this.ensureSamplesForCode(this.currentCode);
              await this.replInstance.evaluate(this.currentCode);
              console.log(`✅ Visual feedback restored for LiveCodingUnit ${this.id}`);
            } catch (err) {
              console.warn(`LiveCodingUnit ${this.id}: Error restoring visual feedback:`, err);
            }
          }, 150); // Small delay to ensure everything is ready
        }
        
        // Register samples if we have any (improved timing)
        const needsRegistration = this.hasPendingSamples || (this.sampleBank && this.sampleBank.size > 0);
        if (needsRegistration) {
          console.log(`LiveCodingUnit ${this.id}: Registering ${this.sampleBank.size} samples...`);
          
          // Wait for REPL to be ready for samples with longer timeout
          const replReady = await this._waitForReplReady(3000); // Increased timeout
          if (!replReady) {
            console.warn(`LiveCodingUnit ${this.id}: REPL context not ready after 3s, but continuing...`);
          }
          
          const registrationSuccess = await this.updateStrudelSampleBank();
          if (registrationSuccess) {
            this.hasPendingSamples = false;
            console.log(`LiveCodingUnit ${this.id}: Sample registration completed successfully`);
          } else {
            console.warn(`LiveCodingUnit ${this.id}: Sample registration failed, will retry later`);
          }
        }
        
        // Apply any pending code
        if (this.pendingCode) {
          console.log(`LiveCodingUnit ${this.id}: Applying pending code:`, this.pendingCode);
          this.setCode(this.pendingCode);
          this.pendingCode = null;
        }
        
        // If unit was playing before, restore playback
        if (this.isPlaying) {
          console.log(`LiveCodingUnit ${this.id}: Restoring playback state`);
          setTimeout(async () => {
            try {
              await this.ensureSamplesForCode(this.currentCode);
              await this.evaluate();
              
              // Only restart if element changed (avoid double-start)
              if (elementChanged) {
                this.play();
              }
            } catch (err) {
              console.warn(`LiveCodingUnit ${this.id}: Error restoring playback:`, err);
            }
          }, 100); // Longer delay for stability
        } else if (this.currentCode && this.currentCode !== this.basePattern) {
          // Even if not playing, restore visual feedback for existing code
          console.log(`LiveCodingUnit ${this.id}: Restoring visual feedback for non-playing unit`);
          setTimeout(async () => {
            try {
              await this.ensureSamplesForCode(this.currentCode);
              await this.replInstance.evaluate(this.currentCode);
              console.log(`✅ Visual feedback restored for non-playing LiveCodingUnit ${this.id}`);
            } catch (err) {
              console.warn(`LiveCodingUnit ${this.id}: Error restoring visual feedback for non-playing unit:`, err);
            }
          }, 150);
        }
        
        // Trigger retry for any pending samples now that REPL is fully ready
        if (this.hasPendingSamples) {
          console.log(`LiveCodingUnit ${this.id}: REPL now ready, triggering immediate sample registration retry`);
          setTimeout(() => this._retryPendingSampleRegistration(), 500);
        }
        
      } catch (err) {
        console.error(`LiveCodingUnit ${this.id}: Error during full REPL setup:`, err);
      }
    } else if (this.replInstance && !this.editorInstance) {
      console.log(`LiveCodingUnit ${this.id}: Immediate connection established - waiting for full editor`);
    }
  }

  /**
   * Persist the current code to config
   */
  persistCurrentCode() {
    try {
      console.log('🔄 persistCurrentCode() called');
      const code = this.getCurrentCode();
      console.log('🔄 Code retrieved for persistence:', code);
      
      // Update our internal state
      this.currentCode = code;
      
      // Dispatch event to update unit config
      const updateEvent = new CustomEvent('updateUnitConfig', {
        detail: { unitId: this.id, config: { strudelCode: code }, source: 'LiveCodingUnit.persist' }
      });
      document.dispatchEvent(updateEvent);
      
      console.log('🔄 Code persisted successfully:', code);
    } catch (err) {
      console.error(`LiveCodingUnit ${this.id}: Error persisting code:`, err);
    }
  }

  /**
   * Retry registering pending samples when REPL context becomes available
   */
  async _retryPendingSampleRegistration() {
    // TEMPORARILY DISABLED - this creates infinite loops without helping
    return false;
    
    if (!this.hasPendingSamples || Object.keys(this.pendingSamples || {}).length === 0) {
      return false;
    }
    
    console.log(`LiveCodingUnit ${this.id}: Retrying registration of ${Object.keys(this.pendingSamples).length} pending samples`);
    
    // Wait for context to be ready
    const contextReady = await this._waitForReplReady(5000);
    if (!contextReady) {
      console.warn(`LiveCodingUnit ${this.id}: Context still not ready, cannot retry sample registration`);
      return false;
    }
    
    // Move pending samples back to sample bank temporarily for registration
    const tempSamples = { ...this.pendingSamples };
    
    try {
      // Attempt registration again
      const success = await this.updateStrudelSampleBank();
      if (success) {
        console.log(`LiveCodingUnit ${this.id}: Successfully registered pending samples on retry`);
        this.pendingSamples = {};
        this.hasPendingSamples = false;
        return true;
      }
    } catch (err) {
      console.error(`LiveCodingUnit ${this.id}: Failed to register pending samples on retry:`, err);
    }
    
    return false;
  }

  /**
   * Check and retry pending operations periodically
   */
  _startPendingRetryLoop() {
    // TEMPORARILY DISABLED - this creates infinite noise without helping
    return;
    
    if (this._retryInterval) {
      clearInterval(this._retryInterval);
    }
    
    this._retryInterval = setInterval(async () => {
      if (this.hasPendingSamples && this.replInstance) {
        console.log(`LiveCodingUnit ${this.id}: Checking for pending sample registration...`);
        const success = await this._retryPendingSampleRegistration();
        if (success) {
          clearInterval(this._retryInterval);
          this._retryInterval = null;
        }
      }
    }, 2000); // Check every 2 seconds
  }

  /**
   * Check if the unit is ready to receive sounds
   * Now considers both immediate and full connections
   */
  isReadyForSounds() {
    // With immediate connection, we show ready status even before full editor is available
    return !!(this.replInstance);
  }

  /**
   * Add a sound from evolutionary discovery to the sample bank
   * @param {Object} cellData - Cell data from phylogenetic tree
   * @param {Object} renderParams - Render parameters (duration, pitch, velocity)
   * @returns {Promise<string>} - Promise that resolves with the sample name
   */
  async addSoundToBank(cellData, renderParams = {}) {
    const { genomeId } = cellData;
    if (!genomeId) {
      throw new Error('Missing genomeId in cellData');
    }

  // Create a concise unique sample name: u<unitIndex>_s<seq>
  // (replaces older verbose unit<id>_evo_<n> scheme)
  const sampleName = `${this.shortUnitId}_s${this.sampleCounter++}`;
    
    // Default render parameters
    const finalRenderParams = {
      duration: renderParams.duration || cellData.duration || 4,
      pitch: renderParams.pitch || cellData.noteDelta || cellData.pitch || 0,
      velocity: renderParams.velocity || cellData.velocity || 1
    };

    console.log(`LiveCodingUnit ${this.id}: Adding sound to bank`, {
      genomeId,
      sampleName,
      renderParams: finalRenderParams,
      hasDirectUrl: !!cellData.genomeUrl
    });

    try {
      // Create cache key for this specific render combination
      const cacheKey = `${genomeId}-${finalRenderParams.duration}_${finalRenderParams.pitch}_${finalRenderParams.velocity}`;
      
      // Check if we already have a blob URL for this exact combination
      if (this.blobUrlCache.has(cacheKey)) {
        const existingBlobUrl = this.blobUrlCache.get(cacheKey);
        console.log(`Using cached blob URL for ${cacheKey}`);
        
        // Add to sample bank with existing blob URL
        this.sampleBank.set(genomeId, {
          name: sampleName,
          blobUrl: existingBlobUrl,
          metadata: {
            genomeId,
            ...finalRenderParams,
            experiment: cellData.experiment,
            evoRunId: cellData.evoRunId
          }
        });
        
  await this.updateStrudelSampleBank();
        return { sampleName, strudelRegistered: !!this.replInstance };
      }

      // Determine how to get the audio data
      let renderResult;
      
      if (cellData.genomeUrl) {
        // Use direct genome URL with SoundRenderer.renderGenome
        console.log(`Using direct genome URL: ${cellData.genomeUrl}`);
        
        renderResult = await new Promise((resolve, reject) => {
          SoundRenderer.renderGenome(
            cellData.genomeUrl,
            finalRenderParams,
            (result) => {
              if (result.success && result.audioBuffer) {
                resolve(result);
              } else {
                reject(new Error(result.error || 'Render failed'));
              }
            },
            (progress) => {
              console.log(`Rendering progress for ${sampleName}: ${progress.progress}%`);
            }
          );
        });
      } else {
        // Use the standard SoundRenderer.renderSound method
        console.log('Using standard sound rendering pipeline');
        
        renderResult = await new Promise((resolve, reject) => {
          SoundRenderer.renderSound(
            {
              genomeId,
              experiment: cellData.experiment || 'unknown',
              evoRunId: cellData.evoRunId || 'unknown'
            },
            finalRenderParams,
            (result) => {
              if (result.success && result.audioBuffer) {
                resolve(result);
              } else {
                reject(new Error(result.error || 'Render failed'));
              }
            },
            (progress) => {
              console.log(`Rendering progress for ${sampleName}: ${progress.progress}%`);
            }
          );
        });
      }

      // Convert AudioBuffer to blob URL
      const blobUrl = await this.audioBufferToBlobUrl(renderResult.audioBuffer);
      
      // Cache the blob URL
      this.blobUrlCache.set(cacheKey, blobUrl);

      // Add to sample bank
      this.sampleBank.set(genomeId, {
        name: sampleName,
        blobUrl,
        metadata: {
          genomeId,
          ...finalRenderParams,
          experiment: cellData.experiment,
          evoRunId: cellData.evoRunId,
          audioBuffer: renderResult.audioBuffer // Keep reference for potential future use
        }
      });

      // Update Strudel's sample bank
  const strudelRegistered = await this.updateStrudelSampleBank();

  // Note: Skipping experimental raw data registration to keep REPL context stable on first use

      // Always generate code if auto-generate is enabled, regardless of registration status
      // The code will be applied when the editor opens if not registered yet
      if (this.autoGenerateCode) {
        await this.generateCodeWithNewSample(sampleName);
        // If not ready, code will apply on attach
        if (!strudelRegistered) {
          console.log(`LiveCodingUnit ${this.id}: Code generated for future use when editor opens`);
        }
        // Safety: ensure we have a non-empty, valid pattern to avoid first-eval issues
        const code = (this.currentCode || '').trim();
        if (!code || (!code.includes('s(') && !code.includes('sound('))) {
          this.setCode(`s("${sampleName}").gain(0.8)`);
        }
      }

      console.log(`LiveCodingUnit ${this.id}: Successfully added sound to bank`, {
        sampleName,
        genomeId,
        blobUrl: blobUrl.substring(0, 50) + '...',
        strudelRegistered
      });

      return { sampleName, strudelRegistered };
    } catch (error) {
      console.error(`LiveCodingUnit ${this.id}: Error adding sound to bank:`, error);
      throw error;
    }
  }

  /**
   * Alternative approach: Register sample using raw audio data
   * @param {string} sampleName - Name to register the sample under
   * @param {AudioBuffer} audioBuffer - Audio buffer to register
   */
  async registerSampleRawData(sampleName, audioBuffer) {
    console.log('🧪 Attempting raw PCM data registration...');
    
    try {
      // Get the raw audio data
      const channelData = audioBuffer.getChannelData(0); // Get first channel
      
      // Try to register this directly with Strudel
  if (this.replInstance && this.replInstance.evaluate) {
        const registrationCode = `
          console.log('🧪 Registering raw audio data for ${sampleName}...');
          // Try to set the sample directly in the sample bank
          const sampleData = new Float32Array([${Array.from(channelData).slice(0, 1000).join(',')}]); // Limit size for eval
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const buffer = audioCtx.createBuffer(${audioBuffer.numberOfChannels}, ${Math.min(audioBuffer.length, 1000)}, ${audioBuffer.sampleRate});
          buffer.getChannelData(0).set(sampleData);
          
          // Register with samples function
          samples({
            '${sampleName}': buffer
          }, '');
          console.log('✅ Raw audio data registration completed for ${sampleName}');
        `;

  await this.replInstance.evaluate(registrationCode);
        console.log('✅ Raw PCM data registration attempted');
      }
    } catch (err) {
      console.error('❌ Raw PCM data registration failed:', err);
    }
  }

  /**
   * Convert AudioBuffer to blob URL for use with Strudel
   * @param {AudioBuffer} audioBuffer - AudioBuffer to convert
   * @returns {Promise<string>} - Promise that resolves with blob URL
   */
  async audioBufferToBlobUrl(audioBuffer) {
    // First, analyze the audio content to verify it contains sound
    const audioAnalysis = this.analyzeAudioContent(audioBuffer);
    if (!audioAnalysis.containsSound) {
      console.warn('⚠️ Audio buffer appears to contain no sound data - this may explain why playback is silent');
    }
    
    // Try alternative approach: Use OfflineAudioContext to create better quality WAV
    console.log('🧪 Creating high-quality WAV with OfflineAudioContext...');
    try {
      // Create offline context with same properties as source
      const offlineContext = new OfflineAudioContext(
        audioBuffer.numberOfChannels,
        audioBuffer.length,
        audioBuffer.sampleRate
      );
      
      // Create source in offline context
      const source = offlineContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(offlineContext.destination);
      source.start(0);
      
      // Render the audio
      const renderedBuffer = await offlineContext.startRendering();
      
      // Convert rendered buffer to WAV
      const wavArrayBuffer = this.audioBufferToWav(renderedBuffer);
      const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });
      const blobUrl = URL.createObjectURL(blob);
      
      // Test the new blob URL
      console.log('🧪 Testing offline-rendered blob URL...');
      const audio = new Audio(blobUrl);
      audio.volume = 0.3;
      audio.addEventListener('loadeddata', () => {
        console.log(`✅ Offline-rendered blob URL loaded (duration: ${audio.duration}s)`);
        // Quick test
        audio.currentTime = 0;
        audio.play().then(() => {
          console.log('✅ Offline-rendered blob URL playback started');
          setTimeout(() => {
            audio.pause();
            audio.currentTime = 0;
          }, 200);
        }).catch(err => {
          console.error('❌ Offline-rendered blob URL playback failed:', err);
        });
      });
      audio.addEventListener('error', (err) => {
        console.error(`❌ Offline-rendered blob URL loading failed:`, err);
      });
      audio.load();
      
      console.log('Offline-rendered blob creation details:', {
        originalLength: audioBuffer.length,
        renderedLength: renderedBuffer.length,
        sampleRate: renderedBuffer.sampleRate,
        channels: renderedBuffer.numberOfChannels,
        wavSize: wavArrayBuffer.byteLength,
        blobSize: blob.size,
        blobUrl: blobUrl.substring(0, 80) + '...'
      });
      
      return blobUrl;
      
    } catch (err) {
      console.error('❌ OfflineAudioContext approach failed:', err);
      
      // Fallback to original method
      const wavArrayBuffer = this.audioBufferToWav(audioBuffer);
      const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });
      const blobUrl = URL.createObjectURL(blob);
      
      console.log('Fallback blob creation details:', {
        audioBufferLength: audioBuffer.length,
        audioBufferSampleRate: audioBuffer.sampleRate,
        audioBufferChannels: audioBuffer.numberOfChannels,
        wavArrayBufferSize: wavArrayBuffer.byteLength,
        blobSize: blob.size,
        blobType: blob.type,
        blobUrl: blobUrl.substring(0, 80) + '...'
      });
      
      return blobUrl;
    }
  }

  /**
   * Convert AudioBuffer to WAV ArrayBuffer
   * Based on: https://github.com/Jam3/audiobuffer-to-wav
   */
  audioBufferToWav(buffer) {
    const length = buffer.length;
    const numberOfChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const bytesPerSample = 2; // 16-bit
    const blockAlign = numberOfChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const bufferSize = 44 + dataSize;

    const arrayBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(arrayBuffer);

    // WAV header
    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };

    writeString(0, 'RIFF');
    view.setUint32(4, bufferSize - 8, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true); // PCM format chunk size
    view.setUint16(20, 1, true); // PCM format
    view.setUint16(22, numberOfChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bytesPerSample * 8, true); // bits per sample
    writeString(36, 'data');
    view.setUint32(40, dataSize, true);

    // Convert float samples to 16-bit PCM
    let offset = 44;
    for (let i = 0; i < length; i++) {
      for (let channel = 0; channel < numberOfChannels; channel++) {
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
        view.setInt16(offset, sample * 0x7FFF, true);
        offset += 2;
      }
    }

    return arrayBuffer;
  }

  /**
   * Analyze AudioBuffer to verify it contains actual audio data
   * @param {AudioBuffer} audioBuffer - AudioBuffer to analyze
   * @returns {Object} - Analysis results
   */
  analyzeAudioContent(audioBuffer) {
    console.log('🔍 Analyzing audio content...');
    
    try {
      const channelData = audioBuffer.getChannelData(0); // Analyze first channel
      const length = channelData.length;
      
      // Calculate basic statistics
      let min = Infinity;
      let max = -Infinity;
      let sum = 0;
      let sumSquares = 0;
      let nonZeroSamples = 0;
      let maxAbsValue = 0;
      
      for (let i = 0; i < length; i++) {
        const sample = channelData[i];
        min = Math.min(min, sample);
        max = Math.max(max, sample);
        sum += sample;
        sumSquares += sample * sample;
        
        if (sample !== 0) {
          nonZeroSamples++;
        }
        
        maxAbsValue = Math.max(maxAbsValue, Math.abs(sample));
      }
      
      const mean = sum / length;
      const variance = (sumSquares / length) - (mean * mean);
      const rms = Math.sqrt(sumSquares / length);
      const nonZeroPercent = (nonZeroSamples / length) * 100;
      
      // Check for peaks (values > 10% of max)
      const peakThreshold = maxAbsValue * 0.1;
      let peakCount = 0;
      for (let i = 0; i < length; i++) {
        if (Math.abs(channelData[i]) > peakThreshold) {
          peakCount++;
        }
      }
      
      const analysis = {
        duration: audioBuffer.duration,
        sampleRate: audioBuffer.sampleRate,
        channels: audioBuffer.numberOfChannels,
        length: length,
        min: min,
        max: max,
        mean: mean,
        rms: rms,
        variance: variance,
        maxAbsValue: maxAbsValue,
        nonZeroSamples: nonZeroSamples,
        nonZeroPercent: nonZeroPercent.toFixed(2),
        peakCount: peakCount,
        peakPercent: (peakCount / length * 100).toFixed(2),
        containsSound: nonZeroSamples > 0 && maxAbsValue > 0.001, // Threshold for "actual sound"
        signalStrength: rms > 0.01 ? 'Strong' : rms > 0.001 ? 'Weak' : 'Very Weak/Silent'
      };
      
      console.log('📊 Audio Content Analysis:', analysis);
      
      // Additional diagnostic info
      if (analysis.containsSound) {
        console.log('✅ Audio contains sound data');
        console.log(`📈 Signal strength: ${analysis.signalStrength} (RMS: ${rms.toFixed(6)})`);
        console.log(`📊 ${analysis.nonZeroPercent}% non-zero samples, ${analysis.peakPercent}% peaks`);
        
        // Show first few samples for inspection
        const firstSamples = Array.from(channelData.slice(0, 10)).map(s => s.toFixed(6));
        console.log('🔍 First 10 samples:', firstSamples);
        
        // Show some middle samples
        const midStart = Math.floor(length / 2);
        const middleSamples = Array.from(channelData.slice(midStart, midStart + 10)).map(s => s.toFixed(6));
        console.log('🔍 Middle 10 samples:', middleSamples);
      } else {
        console.log('❌ Audio appears to be silent or contains no meaningful sound data');
        console.log(`📉 Max absolute value: ${maxAbsValue.toFixed(8)}`);
        console.log(`📉 RMS: ${rms.toFixed(8)}`);
      }
      
      return analysis;
      
    } catch (err) {
      console.error('❌ Audio content analysis failed:', err);
      return { error: err.message, containsSound: false };
    }
  }

  /**
   * Generate a test tone AudioBuffer for testing purposes
   * @param {number} frequency - Frequency in Hz (default: 440)
   * @param {number} duration - Duration in seconds (default: 1)
   * @param {number} sampleRate - Sample rate (default: 44100)
   * @returns {AudioBuffer} - Generated test tone
   */
  generateTestTone(frequency = 440, duration = 1, sampleRate = 44100) {
    console.log(`🧪 Generating test tone: ${frequency}Hz, ${duration}s`);
    
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
    const channelData = audioBuffer.getChannelData(0);
    
    // Generate sine wave
    for (let i = 0; i < channelData.length; i++) {
      const t = i / sampleRate;
      channelData[i] = 0.3 * Math.sin(2 * Math.PI * frequency * t) * Math.exp(-t * 2); // Exponential decay
    }
    
    console.log('✅ Test tone generated');
    return audioBuffer;
  }

  /**
   * Add a test sample for debugging purposes
   */
  async addTestSample() {
    console.log('🧪 Adding test sample with known audio content...');
    
    try {
      // Generate a test tone
      const testAudioBuffer = this.generateTestTone(440, 1); // 440Hz for 1 second
      
      // Analyze the test audio to verify it contains sound
      const analysis = this.analyzeAudioContent(testAudioBuffer);
      if (!analysis.containsSound) {
        console.error('❌ Generated test tone contains no sound - this indicates a problem with audio generation');
        return;
      }
      
      // Convert to blob URL
      const blobUrl = await this.audioBufferToBlobUrl(testAudioBuffer);
      
      // Add to sample bank with fake genome ID
  const testGenomeId = 'test_tone_' + Date.now();
  const sampleName = `${this.shortUnitId}_test_${this.sampleCounter++}`;
      
      this.sampleBank.set(testGenomeId, {
        name: sampleName,
        blobUrl,
        metadata: {
          genomeId: testGenomeId,
          type: 'test_tone',
          frequency: 440,
          duration: 1,
          audioBuffer: testAudioBuffer
        }
      });
      
      // Register with Strudel
      await this.updateStrudelSampleBank();
      
      // Generate code using the test sample
      if (this.autoGenerateCode) {
        await this.generateCodeWithNewSample(sampleName);
      }
      
      console.log('✅ Test sample added successfully:', sampleName);
      return sampleName;
      
    } catch (err) {
      console.error('❌ Failed to add test sample:', err);
    }
  }

  /**
   * Update Strudel's sample bank with current samples (improved isolation)
   */
  async updateStrudelSampleBank() {
    // Create sample map for Strudel (use blob URLs; let Strudel decode internally)
    const sampleMap = {};
    this.sampleBank.forEach((sampleData) => {
      sampleMap[sampleData.name] = sampleData.blobUrl;
    });

    if (Object.keys(sampleMap).length === 0) {
      console.log(`LiveCodingUnit ${this.id}: No samples to register`);
      return true;
    }

    console.log(`LiveCodingUnit ${this.id}: Registering ${Object.keys(sampleMap).length} samples:`, {
      sampleNames: Object.keys(sampleMap),
      unitId: this.id,
      replInstance: !!this.replInstance,
      replContext: !!this.replInstance?.context,
      editorInstance: !!this.editorInstance
    });

    // CRITICAL: Only register samples with THIS unit's REPL instance
    if (this.replInstance && this.editorInstance && this.replInstance.context) {
      try {
        console.log(`LiveCodingUnit ${this.id}: Direct REPL context registration...`);

        // Ensure we have a per-unit set of what was registered already
        if (!this._registeredSamples) this._registeredSamples = new Set();

        // Compute delta to avoid re-registering
        const delta = {};
        Object.entries(sampleMap).forEach(([name, url]) => {
          if (!this._registeredSamples.has(name)) {
            delta[name] = url;
          }
        });

        const deltaNames = Object.keys(delta);
        if (deltaNames.length === 0) {
          console.log(`ℹ️ LiveCodingUnit ${this.id}: No new samples to register (already registered: ${this._registeredSamples.size})`);
          return true;
        }

        // IMPROVED: Direct registration with proper error handling
        if (typeof this.replInstance.context.samples === 'function') {
          console.log(`LiveCodingUnit ${this.id}: Using context.samples() function...`);
          await this.replInstance.context.samples(delta);
          console.log(`✅ LiveCodingUnit ${this.id}: Context samples registration completed`);
        } else {
          console.warn(`LiveCodingUnit ${this.id}: No context.samples function, trying fallback...`);
          // Fallback: store under context._samples
          if (!this.replInstance.context._samples) this.replInstance.context._samples = {};
          Object.assign(this.replInstance.context._samples, delta);
        }

        // REMOVED: No global registration - keep units isolated

        // Mark as registered
        deltaNames.forEach(n => this._registeredSamples.add(n));
        this._lastRegistrationAt = Date.now();
        
        console.log(`✅ LiveCodingUnit ${this.id}: Registered ${deltaNames.length} new sample(s):`, deltaNames);
        
        // Verify registration worked
        const contextSamples = this.replInstance.context._samples || {};
        console.log(`LiveCodingUnit ${this.id}: Context now has ${Object.keys(contextSamples).length} samples:`, Object.keys(contextSamples));
        
        return true;

      } catch (error) {
        console.error(`LiveCodingUnit ${this.id}: ❌ Error registering samples with unit's REPL:`, error);
        return false;
      }
    }

    // Fallback: Store in unit-specific pending samples (avoid global pollution)
    console.log(`LiveCodingUnit ${this.id}: REPL not ready, storing samples for later registration`);
    if (!this.pendingSamples) {
      this.pendingSamples = {};
    }
    Object.assign(this.pendingSamples, sampleMap);
    
    this.hasPendingSamples = true;
    
    // Start retry loop for pending samples
    this._startPendingRetryLoop();
    
    console.warn(`LiveCodingUnit ${this.id}: ⚠️ REPL not ready. Samples stored for later registration.`);
    return false;
  }

  /**
   * Parse a Strudel pattern to extract sample information and structure
   * @param {string} code - Strudel code to parse
   * @returns {Object} - Parsed pattern information
   */
  parseStrudelPattern(code) {
    const result = {
      hasManualEdits: false,
      chainMethods: [],
      samplePattern: null,
      samples: [],
      originalPattern: null,
      originalChainMethods: '' // Preserve original formatting including line breaks
    };

    try {
      // Extract the main s("...") pattern and any chained methods
      // Use dotall flag (s) to match newlines in the chained methods
      const mainPatternMatch = code.match(/s\(['"](.+?)['"]\)(.*)/s);
      if (!mainPatternMatch) {
        return result;
      }

      const patternContent = mainPatternMatch[1];
      const chainedMethods = mainPatternMatch[2]; // Don't trim to preserve line breaks
      
      result.originalPattern = patternContent;
      result.originalChainMethods = chainedMethods; // Store original with formatting
      result.chainMethods = chainedMethods ? [chainedMethods] : [];

      // Parse the pattern content
      if (patternContent.startsWith('[') && patternContent.endsWith(']')) {
        // Complex pattern with brackets
        result.samplePattern = this.parseComplexPattern(patternContent.slice(1, -1));
      } else {
        // Simple space-separated pattern
        result.samplePattern = this.parseSimplePattern(patternContent);
      }

      // Extract all sample references
      result.samples = this.extractSampleReferences(patternContent);
      
      console.log('Parsed Strudel pattern:', result);
      return result;
      
    } catch (err) {
      console.warn('Error parsing Strudel pattern:', err);
      return result;
    }
  }

  /**
   * Parse a complex pattern with nested brackets and modifiers
   * @param {string} content - Pattern content inside brackets
   * @returns {Array} - Parsed structure
   */
  parseComplexPattern(content) {
    const elements = [];
    let current = '';
    let depth = 0;
    let inQuotes = false;
    
    for (let i = 0; i < content.length; i++) {
      const char = content[i];
      
      if (char === '"' || char === "'") {
        inQuotes = !inQuotes;
        current += char;
      } else if (!inQuotes) {
        if (char === '[') {
          depth++;
          current += char;
        } else if (char === ']') {
          depth--;
          current += char;
        } else if (char === ' ' && depth === 0) {
          if (current.trim()) {
            elements.push(this.parsePatternElement(current.trim()));
            current = '';
          }
        } else {
          current += char;
        }
      } else {
        current += char;
      }
    }
    
    if (current.trim()) {
      elements.push(this.parsePatternElement(current.trim()));
    }
    
    return elements;
  }

  /**
   * Parse a simple space-separated pattern
   * @param {string} content - Pattern content
   * @returns {Array} - Parsed elements
   */
  parseSimplePattern(content) {
    return content.split(/\s+/).filter(Boolean).map(element => 
      this.parsePatternElement(element)
    );
  }

  /**
   * Parse an individual pattern element (sample with potential modifiers)
   * @param {string} element - Element to parse
   * @returns {Object} - Parsed element
   */
  parsePatternElement(element) {
    const result = {
      type: 'unknown',
      content: element,
      isGroup: false,
      samples: [],
      modifiers: ''
    };

    if (element.startsWith('[') && element.endsWith(']')) {
      // Nested group
      result.type = 'group';
      result.isGroup = true;
      result.content = element;
      result.samples = this.extractSampleReferences(element);
    } else {
      // Individual sample with potential modifiers
      const sampleMatch = element.match(/^(u\d+_s\d+|u\d+_test_\d+)(.*)$/);
      if (sampleMatch) {
        result.type = 'sample';
        result.samples = [sampleMatch[1]];
        result.modifiers = sampleMatch[2] || '';
      } else {
        result.type = 'other';
      }
    }
    
    return result;
  }

  /**
   * Extract all sample references from a pattern string
   * @param {string} pattern - Pattern to search
   * @returns {Array} - Array of sample names found
   */
  extractSampleReferences(pattern) {
    const sampleRegex = /(u\d+_s\d+|u\d+_test_\d+)/g;
    const matches = pattern.match(sampleRegex) || [];
    return [...new Set(matches)]; // Remove duplicates
  }

  /**
   * Check if the current code has manual edits compared to what auto-generation would produce
   * @returns {boolean} - True if code appears to have manual edits
   */
  hasManualEdits() {
    const currentCode = this.getCurrentCode().trim();
    
    // Parse current code to get the samples it contains
    const parsed = this.parseStrudelPattern(currentCode);
    if (!parsed.samples || parsed.samples.length === 0) {
      console.log('🔧 hasManualEdits: No samples found, returning false');
      return false; // No samples, probably base pattern
    }
    
    // Generate what auto-generation would produce for these same samples
    const currentSamples = parsed.samples;
    const autoGeneratedCode = this.generateFreshCode(currentSamples);
    
    // For comparison, normalize whitespace (but preserve the intent)
    // This way, line breaks and formatting changes are considered manual edits
    const normalizeCode = (code) => {
      // Replace multiple whitespace/newlines with single spaces for comparison
      // But keep the overall structure
      return code.replace(/\s+/g, ' ').trim();
    };
    
    const normalizedCurrent = normalizeCode(currentCode);
    const normalizedGenerated = normalizeCode(autoGeneratedCode);
    const hasEdits = normalizedCurrent !== normalizedGenerated;
    
    // Additionally, check if there are line breaks in the original (formatting edits)
    const hasFormattingEdits = currentCode.includes('\n') && !autoGeneratedCode.includes('\n');
    
    const finalHasEdits = hasEdits || hasFormattingEdits;
    
    console.log('🔧 Manual edit detection:', {
      currentCode,
      autoGeneratedCode,
      normalizedCurrent,
      normalizedGenerated,
      currentSamples,
      hasEdits,
      hasFormattingEdits,
      finalHasEdits,
      exact_match: currentCode === autoGeneratedCode
    });
    
    return finalHasEdits;
  }
  /**
   * Generate new Strudel code that incorporates a newly added sample
   * @param {string} sampleName - Name of the newly added sample
   */
  async generateCodeWithNewSample(sampleName) {
    // CRITICAL: Persist any manual edits from the editor FIRST
    // This ensures getCurrentCode() will see the latest manual edits
    try {
      this.persistCurrentCode();
      console.log('🔄 Manual edits persisted before code generation');
    } catch (err) {
      console.warn('Failed to persist current code:', err);
    }
    
    // Ensure maxSamplesInPattern is set (for backward compatibility)
    if (!this.maxSamplesInPattern) {
      this.maxSamplesInPattern = 4;
    }
    
    // Ensure sampleMultiplier is set (for backward compatibility)
    if (!this.sampleMultiplier) {
      this.sampleMultiplier = 1;
    }
    
    // Check if we should preserve manual edits
    const shouldPreserveEdits = this.preserveManualEdits && this.hasManualEdits();
    
    let existingSampleNames;
    
    if (shouldPreserveEdits) {
      // IMPROVED: When preserving edits, use samples from current code + ensure new sample is included
      const currentCode = this.getCurrentCode();
      const parsed = this.parseStrudelPattern(currentCode);
      const samplesInCurrentCode = parsed.samples || [];
      
      // Include samples from current code, plus the new sample
      const candidateSamples = [...samplesInCurrentCode];
      if (!candidateSamples.includes(sampleName)) {
        candidateSamples.push(sampleName);
      }
      
      // Calculate max unique samples considering multiplier and total limit
      const multiplier = this.sampleMultiplier || 1;
      const maxTotalSamples = this.maxSamplesInPattern || 4;
      const maxUniqueSamples = Math.floor(maxTotalSamples / multiplier);
      
      // If we exceed maxUniqueSamples, remove oldest samples (keep newest ones including the new sample)
      if (candidateSamples.length > maxUniqueSamples) {
        // Keep the new sample and the most recent ones from current code
        const samplesWithoutNew = candidateSamples.filter(s => s !== sampleName);
        const recentSamples = samplesWithoutNew.slice(-(maxUniqueSamples - 1));
        existingSampleNames = [...recentSamples, sampleName];
      } else {
        existingSampleNames = candidateSamples;
      }
      
      console.log('🔧 generateCodeWithNewSample (preserve mode) Debug:', {
        newSample: sampleName,
        samplesInCurrentCode,
        candidateSamples,
        existingSamples: existingSampleNames,
        currentCode,
        maxSamplesInPattern: this.maxSamplesInPattern,
        sampleMultiplier: this.sampleMultiplier,
        maxUniqueSamples,
        maxTotalSamples,
        preserveEditsEnabled: this.preserveManualEdits
      });
    } else {
      // Original behavior: use all samples from bank (for fresh generation)
      const allSamples = Array.from(this.sampleBank.values()).map(s => s.name);
      existingSampleNames = allSamples;
      
      console.log('🔧 generateCodeWithNewSample (fresh mode) Debug:', {
        newSample: sampleName,
        existingSamples: existingSampleNames,
        currentCode: this.getCurrentCode(),
        sampleMultiplier: this.sampleMultiplier,
        preserveEditsEnabled: this.preserveManualEdits
      });
    }
    
    console.log('🔧 Manual edit check result:', shouldPreserveEdits);
    
    if (shouldPreserveEdits) {
      console.log('🎼 Preserving manual edits while adding new sample:', sampleName);
      this.currentCode = this.generateCodePreservingEdits(sampleName, existingSampleNames);
    } else {
      console.log('🧪 Generating fresh pattern code');
      this.currentCode = this.generateFreshCode(existingSampleNames);
    }
    
    console.log('🔧 Final result:', this.currentCode);
    
    // Track this as the last auto-generated code (for tracking manual edit history)
    this.lastAutoGeneratedCode = this.currentCode;

    // Update the editor with new code
    this.setCode(this.currentCode, true); // Mark as auto-generated
    
    // Ensure referenced sample(s) are registered before auto-start
    try { await this.ensureSamplesForCode(this.currentCode); } catch {}

    // Automatically start playback when REPL context is ready
    if (this.replInstance && this.isReadyForSounds()) {
      console.log(`LiveCodingUnit ${this.id}: Auto-starting new code for immediate playback`);
      try {
        const startWhenReady = (tries = 0) => {
          if (tries > 10) {
            try { this.play(); } catch (e) { console.error(e); }
          } else {
            setTimeout(() => startWhenReady(tries + 1), 30);
          }
        };
        startWhenReady();
      } catch (err) {
        console.error(`LiveCodingUnit ${this.id}: Auto-start failed:`, err);
      }
    }
    
    console.log(`LiveCodingUnit ${this.id}: Generated pattern code:`);
    console.log(this.currentCode);
  }

  /**
   * Generate fresh code without preserving edits (original behavior)
   * @param {Array} existingSampleNames - All available sample names
   * @returns {string} - Generated Strudel code
   */
  generateFreshCode(existingSampleNames) {
    // Apply sample multiplier to expand samples, but respect maxSamplesInPattern total limit
    const expandedSamples = [];
    const multiplier = this.sampleMultiplier || 1;
    const maxTotalSamples = this.maxSamplesInPattern || 4;
    
    // Calculate how many unique samples we can fit given the multiplier
    const maxUniqueSamples = Math.floor(maxTotalSamples / multiplier);
    const samplesToUse = existingSampleNames.slice(-maxUniqueSamples);
    
    // Expand each sample according to the multiplier
    samplesToUse.forEach(sampleName => {
      for (let i = 0; i < multiplier; i++) {
        expandedSamples.push(sampleName);
      }
    });
    
    // Ensure we don't exceed the total limit (safety check)
    const finalSamples = expandedSamples.slice(0, maxTotalSamples);
    
    if (finalSamples.length === 1) {
      // Single sample instance - create a simple pattern
      const only = finalSamples[0];
      return `s("${only}").gain(0.8)`;
    } else if (finalSamples.length === 2) {
      // Two sample instances - create an alternating pattern
      return `s("${finalSamples.join(' ')}").gain(0.8)`;
    } else {
      // Multiple sample instances - create a more complex pattern
      return `s("[${finalSamples.join(' ')}]").gain(0.8)`;
    }
  }

  /**
   * Generate code while preserving manual edits
   * @param {string} newSampleName - Name of the newly added sample
   * @param {Array} existingSampleNames - All available sample names
   * @returns {string} - Generated Strudel code with preserved edits
   */
  generateCodePreservingEdits(newSampleName, existingSampleNames) {
    const currentCode = this.getCurrentCode().trim();
    const parsed = this.parseStrudelPattern(currentCode);
    
    console.log('🔧 generateCodePreservingEdits Debug:', {
      currentCode,
      newSampleName,
      existingSampleNames,
      parsed
    });
    
    if (!parsed.originalPattern) {
      // Can't parse existing pattern, fall back to fresh generation
      console.warn('Could not parse existing pattern, generating fresh code');
      return this.generateFreshCode(existingSampleNames);
    }
    
    console.log('Preserving edits for pattern:', parsed);
    
    // Determine which samples to keep (last N samples including the new one)
    const recentSamples = existingSampleNames.slice(-this.maxSamplesInPattern);
    const samplesToKeep = new Set(recentSamples);
    
    console.log('🔧 Sample filtering:', {
      allSamples: existingSampleNames,
      maxSamples: this.maxSamplesInPattern,
      recentSamples,
      samplesToKeep: Array.from(samplesToKeep)
    });
    
    // Build new pattern preserving structure where possible
    const newPattern = this.buildPreservedPattern(parsed, samplesToKeep, newSampleName);
    
    // Reconstruct the full code with chain methods, preserving original line breaks
    const chainMethods = parsed.originalChainMethods || 
                        (parsed.chainMethods && parsed.chainMethods.length > 0 ? parsed.chainMethods.join('') : '') ||
                        '.gain(0.8)';
    const result = `s("${newPattern}")${chainMethods}`;
    
    console.log('🔧 Preservation result:', {
      newPattern,
      originalChainMethods: parsed.originalChainMethods,
      chainMethods,
      result
    });
    
    return result;
  }

  /**
   * Build a new pattern preserving manual edits where samples are kept
   * @param {Object} parsed - Parsed pattern information
   * @param {Set} samplesToKeep - Set of sample names to keep
   * @param {string} newSampleName - Name of newly added sample
   * @returns {string} - New pattern content
   */
  buildPreservedPattern(parsed, samplesToKeep, newSampleName) {
    const preservedElements = [];
    const usedSamples = new Set();
    
    // Process existing pattern elements
    if (parsed.samplePattern) {
      for (const element of parsed.samplePattern) {
        if (element.type === 'group') {
          // Handle grouped samples
          const groupSamples = element.samples.filter(s => samplesToKeep.has(s));
          if (groupSamples.length > 0) {
            // Preserve the group with remaining samples
            const groupContent = element.content.slice(1, -1); // Remove outer brackets
            const preservedGroupContent = this.preserveGroupStructure(groupContent, samplesToKeep);
            if (preservedGroupContent) {
              preservedElements.push(`[${preservedGroupContent}]`);
              groupSamples.forEach(s => usedSamples.add(s));
            }
          }
        } else if (element.type === 'sample') {
          // Handle individual samples
          const sampleName = element.samples[0];
          if (samplesToKeep.has(sampleName)) {
            preservedElements.push(element.content); // Keep with modifiers
            usedSamples.add(sampleName);
          }
        } else {
          // Handle other elements (keep as-is if they don't reference removed samples)
          const elementSamples = this.extractSampleReferences(element.content);
          const hasValidSamples = elementSamples.length === 0 || elementSamples.some(s => samplesToKeep.has(s));
          if (hasValidSamples) {
            preservedElements.push(element.content);
            elementSamples.forEach(s => usedSamples.add(s));
          }
        }
      }
    }
    
    // Add any remaining samples that weren't in the original pattern
    const unusedSamples = Array.from(samplesToKeep).filter(s => !usedSamples.has(s));
    const multiplier = this.sampleMultiplier || 1;
    const maxTotalSamples = this.maxSamplesInPattern || 4;
    
    // Apply multiplier to new samples being added, respecting total limit
    unusedSamples.forEach(sampleName => {
      if (sampleName === newSampleName) {
        // Apply multiplier to the new sample, but don't exceed total limit
        const currentCount = preservedElements.length;
        const remainingSlots = maxTotalSamples - currentCount;
        const instancesToAdd = Math.min(multiplier, remainingSlots);
        
        for (let i = 0; i < instancesToAdd; i++) {
          preservedElements.push(sampleName);
        }
      } else {
        // Add other unused samples normally (if space allows)
        if (preservedElements.length < maxTotalSamples) {
          preservedElements.push(sampleName);
        }
      }
    });
    
    // Note: Total sample instances now respects maxSamplesInPattern limit
    
    // Build final pattern
    if (preservedElements.length <= 2) {
      // Simple pattern
      return preservedElements.join(' ');
    } else {
      // Complex pattern with brackets
      return `[${preservedElements.join(' ')}]`;
    }
  }

  /**
   * Preserve the structure within a group while filtering out removed samples
   * @param {string} groupContent - Content inside group brackets
   * @param {Set} samplesToKeep - Set of sample names to keep
   * @returns {string} - Preserved group content
   */
  preserveGroupStructure(groupContent, samplesToKeep) {
    // This is a simplified version - could be enhanced for more complex nested structures
    const elements = groupContent.split(/\s+/).filter(element => {
      const samples = this.extractSampleReferences(element);
      return samples.length === 0 || samples.some(s => samplesToKeep.has(s));
    });
    
    return elements.join(' ');
  }

  /**
   * Manually set the Strudel code (isolated unit-specific approach)
   * @param {string} code - Strudel code to set
   * @param {boolean} isAutoGenerated - Whether this code was auto-generated (for tracking manual edits)
   */
  setCode(code, isAutoGenerated = false) {
    console.log(`LiveCodingUnit ${this.id}: setCode called with:`, code);
    this.currentCode = code;
    
    // Track auto-generated code for manual edit detection
    if (isAutoGenerated) {
      this.lastAutoGeneratedCode = code;
    }
    
    // Keep the DOM element's attribute in sync to avoid web component resetting code on re-attach
    try {
      if (this.strudelElement) {
        this.strudelElement.setAttribute('code', code);
      }
    } catch (e) {
      console.warn(`LiveCodingUnit ${this.id}: failed to sync strudel element code attribute`, e);
    }
    
    // CRITICAL: Persist code to unit config so it survives unit switching
    // Find the unit in the UnitsPanel and update its strudelCode
    try {
      // Try to update the unit config through the DOM
      const unitElement = document.querySelector(`[data-unit-id="${this.id}"]`);
      if (unitElement) {
        // Trigger a custom event to update the unit config
        const updateEvent = new CustomEvent('updateUnitConfig', {
          detail: { 
            unitId: this.id, 
            config: { strudelCode: code },
            source: 'LiveCodingUnit.setCode'
          }
        });
        document.dispatchEvent(updateEvent);
        console.log(`LiveCodingUnit ${this.id}: Dispatched config update event for code persistence`);
      }
    } catch (error) {
      console.warn(`LiveCodingUnit ${this.id}: Could not dispatch config update:`, error);
    }
    
    // First priority: Use direct REPL instance if available
    if (this.editorInstance) {
      console.log(`LiveCodingUnit ${this.id}: Updating REPL via direct editor instance`);
      try { this.editorInstance.setCode(code); } catch {}
      // Also sync attribute for good measure
      try { this.strudelElement?.setAttribute('code', code); } catch {}
      return;
    }
    
    // Second priority: Use the unit-specific global method
    const updateMethod = window[`updateUnit${this.id}`];
    if (updateMethod) {
      console.log(`LiveCodingUnit ${this.id}: Updating REPL via unit-specific global method`);
      updateMethod(code);
  // Ensure attribute reflects the latest code
  try { this.strudelElement?.setAttribute('code', code); } catch {}
    } else {
      console.log(`LiveCodingUnit ${this.id}: No update method available - storing code for later`);
      // Store code for when the REPL becomes available
      this.pendingCode = code;
    }
  }

  /**
   * Handle cell hover events from phylogenetic tree (similar to LoopingUnit)
   * This makes hovering nodes automatically add sounds to the sample bank
   * @param {Object} cellData - Cell data from hover event
   */
  async handleCellHover(cellData) {
    console.log('LiveCodingUnit handleCellHover:', cellData);
    if (!this.active || this.muted || !cellData) return;

    // Check if unit is ready to receive sounds
    if (!this.isReadyForSounds()) {
      console.log(`LiveCodingUnit ${this.id}: Not ready for sounds - no REPL instance available`);
      return;
    }
    
    // ISOLATION FIX: Prevent cross-contamination by checking if this is the selected unit
    const selectedUnitId = window.debugGetSelectedUnitId?.();
    if (selectedUnitId && selectedUnitId !== this.id) {
      console.log(`LiveCodingUnit ${this.id}: Ignoring hover - not the selected unit (selected: ${selectedUnitId})`);
      return;
    }

    const { genomeId } = cellData;
    if (!genomeId) return;

    try {
      // Check if we already have this sound in our sample bank
      if (this.sampleBank.has(genomeId)) {
        console.log(`LiveCodingUnit ${this.id}: Sound ${genomeId} already in sample bank`);
        return;
      }

      // Add sound to sample bank with render parameters from hover
      const result = await this.addSoundToBank(cellData, {
        duration: cellData.duration || 4,
        pitch: cellData.noteDelta || 0,
        velocity: cellData.velocity || 1
      });

      console.log(`LiveCodingUnit ${this.id}: Successfully added sound from hover: ${result.sampleName}`);

      // Trigger any loop state callback if provided (for consistency with other units)
      if (cellData.config?.onLoopStateChanged) {
        cellData.config.onLoopStateChanged(true);
      }

    } catch (error) {
      console.error(`LiveCodingUnit ${this.id}: Error handling hover:`, error);
      
      // Trigger error callback if provided
      if (cellData.config?.onLoopStateChanged) {
        cellData.config.onLoopStateChanged(false);
      }
    }
  }

  /**
   * Get the current Strudel code
   * @returns {string} - Current code
   */
  getCode() {
    if (this.replInstance) {
      return this.replInstance.getCode();
    }
    return this.currentCode;
  }

  /**
   * Play the current pattern (simplified - no coordination)
   */
  play() {
    if (!this.replInstance) {
      console.warn(`LiveCodingUnit ${this.id}: No REPL instance available for play`);
      return;
    }

    // Get the current code from the editor (including manual edits)
    const code = this.getCurrentCode().trim();
    
    if (!code || code === 'silence') {
      this.stop();
      return;
    }

    console.log(`LiveCodingUnit ${this.id}: Starting playback with code:`, code);
    this._simplePlay(code);
  }

  /**
   * Simple play without coordination (coordination was causing conflicts)
   */
  async _simplePlay(code) {
    const waitForSamples = async (timeoutMs = 300, intervalMs = 20) => {
      const codeStr = code.trim();
      const m = codeStr.match(/s\((['\"])(.*?)\1\)/);
      if (!m) return;
      const inner = m[2];
      const names = inner.startsWith('[') && inner.endsWith(']')
        ? inner.slice(1, -1).split(/\s+/).filter(Boolean)
        : inner.split(/\s+/).filter(Boolean);
      if (!names.length) return;
      const startTime = Date.now();
      while (Date.now() - startTime < timeoutMs) {
        const have = (n) => (this._registeredSamples && this._registeredSamples.has(n));
        if (names.every(have)) return; // ready
        await new Promise(r => setTimeout(r, intervalMs));
      }
    };

    try {
      // Step 1: Stop this unit's existing pattern
      this.stop();
      
      // Step 2: Ensure samples are ready
      await waitForSamples();
      
      // Step 3: Evaluate the code
      await this.evaluate();
      
      // Step 4: Start playback
      await new Promise(resolve => setTimeout(resolve, 50));
      
      if (this.strudelElement && typeof this.strudelElement.start === 'function') {
        this.strudelElement.start();
      } else if (this.replInstance && typeof this.replInstance.start === 'function') {
        this.replInstance.start();
      }
      
      this.isPlaying = true;
      console.log(`LiveCodingUnit ${this.id}: Playback started successfully`);
      
    } catch (err) {
      console.error(`LiveCodingUnit ${this.id}: Play failed:`, err);
    }
  }

  /**
   * Stop the current pattern
   */
  stop() {
    if (this.replInstance) {
      try {
        // Stop using all available methods
        this.strudelElement?.stop?.();
        this.replInstance?.stop?.();
        this.replInstance?.hush?.(); // Immediately stop all sounds
      } catch (err) {
        console.error(`LiveCodingUnit ${this.id}: Error stopping playback:`, err);
      }
      this.isPlaying = false;
    }
  }

  /**
   * Toggle playback
   */
  toggle() {
    if (this.replInstance) {
      if (this.isPlaying) {
        this.stop();
      } else {
        this.play();
      }
    }
  }

  /**
   * Evaluate the current code
   */
  async evaluate() {
    if (!this.replInstance || !this.editorInstance) {
      console.warn(`LiveCodingUnit ${this.id}: Cannot evaluate - missing replInstance or editorInstance`);
      return;
    }

    // Get the current code using the helper method
    let code = this.getCurrentCode();
    
    try {
      // Normalize empty code to silence
      if (!code || code.trim().length === 0) {
        code = 'silence';
      }

      // Ensure samples referenced by the code are registered
      try { 
        await this.ensureSamplesForCode(code); 
      } catch (e) { 
        console.warn('ensureSamplesForCode failed', e); 
      }

      // Stop any currently playing pattern before evaluating new code
      this.replInstance?.stop?.();
      
      // Evaluate the new pattern
      await Promise.resolve(this.replInstance.evaluate(code));
      
      // Store as "last known good" code
      this.currentCode = code;
      
    } catch (err) {
      console.error(`LiveCodingUnit ${this.id}: Error during evaluation:`, err);
      console.error('Problem code was:', code);
      
      // If evaluation fails, try a simple fallback pattern
      if (code !== 'silence') {
        console.log(`LiveCodingUnit ${this.id}: Attempting fallback to silence pattern`);
        try {
          await Promise.resolve(this.replInstance.evaluate('silence'));
        } catch (fallbackErr) {
          console.error(`LiveCodingUnit ${this.id}: Even fallback pattern failed:`, fallbackErr);
        }
      }
    }
  }

  // Parse the code for s("...") and ensure those samples are registered before evaluating
  async ensureSamplesForCode(code) {
    try {
      const match = code.match(/s\((['\"])(.*?)\1\)/);
      if (!match) return;
      const inner = match[2];
      let names = [];
      if (inner.startsWith('[') && inner.endsWith(']')) {
        const content = inner.slice(1, -1);
        names = content.split(/\s+/).filter(Boolean);
      } else {
        names = inner.split(/\s+/).filter(Boolean);
      }
      if (!names.length) return;

      // Build name->resource map from our bank (use blob URLs)
      const nameToResource = {};
      this.sampleBank.forEach((data) => {
        nameToResource[data.name] = data.blobUrl;
      });

      // Determine which names need registration
      if (!this._registeredSamples) this._registeredSamples = new Set();
      const need = names.filter(n => !this._registeredSamples.has(n));
      if (need.length === 0) return;

  const delta = {};
  need.forEach(n => { if (nameToResource[n]) delta[n] = nameToResource[n]; });
      const deltaNames = Object.keys(delta);
      if (deltaNames.length === 0) return;

      // Register directly via the REPL context when available
      if (this.replInstance && this.replInstance.context && typeof this.replInstance.context.samples === 'function') {
        await this.replInstance.context.samples(delta);
      } else if (typeof window !== 'undefined' && typeof window.samples === 'function') {
        // Fallback to global samples()
        await window.samples(delta);
      } else if (this.replInstance && this.replInstance.context) {
        // Last-resort local stash
        if (!this.replInstance.context._samples) this.replInstance.context._samples = {};
        Object.assign(this.replInstance.context._samples, delta);
      }

      // Mark as registered and timestamp for race avoidance
      deltaNames.forEach(n => this._registeredSamples.add(n));
      this._lastRegistrationAt = Date.now();
      console.log(`✅ LiveCodingUnit ${this.id}: ensureSamplesForCode registered`, deltaNames);
    } catch (e) {
      console.warn('ensureSamplesForCode error', e);
    }
  }

  /**
   * Update unit configuration
   */
  updateConfig(config) {
    // Persist any manual edits before updating config
    if (this.replInstance && this.editorInstance && this.strudelElement) {
      this.persistCurrentCode();
    }
    
    Object.assign(this, config);
    
    // Update REPL instance if available
    if (this.strudelElement) {
      // Use the stored strudel-editor element reference
      if (config.sync !== undefined) {
        this.strudelElement.sync = config.sync;
        console.log(`LiveCodingUnit ${this.id}: Updated REPL sync to:`, config.sync);
      }
      if (config.solo !== undefined) {
        this.strudelElement.solo = config.solo;
        console.log(`LiveCodingUnit ${this.id}: Updated REPL solo to:`, config.solo);
        
        // CRITICAL: If this unit is being soloed, make sure other units are not soloed
        if (config.solo === true) {
          console.log(`LiveCodingUnit ${this.id}: Soloing - will disable solo on other units`);
          // Dispatch event to unsolo other units
          document.dispatchEvent(new CustomEvent('soloLiveCodingUnit', {
            detail: { unitId: this.id }
          }));
        }
      }
    } else {
      // Cache flags for later when the element is attached
      if (config.sync !== undefined) this._pendingUiFlags.sync = config.sync;
      if (config.solo !== undefined) this._pendingUiFlags.solo = config.solo;
      console.debug(`LiveCodingUnit ${this.id}: Queued sync/solo for later attach`, this._pendingUiFlags);
    }
    
    // CRITICAL: Update current code if strudelCode is provided
    // This restores the persisted code when switching back to the unit
    if (config.strudelCode !== undefined) {
      this.currentCode = config.strudelCode;
      // Apply to editor if it exists
      if (this.editorInstance) {
        this.editorInstance.setCode(config.strudelCode);
      }
      if (this.strudelElement) {
        this.strudelElement.setAttribute('code', config.strudelCode);
      }
    }
    
    console.log(`LiveCodingUnit ${this.id}: Config updated`);
  }

  /**
   * Called when unit is being deselected (switching to another unit)
   */
  onDeselect() {
    this.persistCurrentCode();
  }

  /**
   * Get information about the current sample bank
   */
  getSampleBankInfo() {
    return {
      sampleCount: this.sampleBank.size,
      samples: Array.from(this.sampleBank.entries()).map(([genomeId, data]) => ({
        genomeId,
        name: data.name,
        metadata: data.metadata
      }))
    };
  }

  /**
   * Remove a sample from the bank
   * @param {string} genomeId - Genome ID to remove
   */
  removeSample(genomeId) {
    const sampleData = this.sampleBank.get(genomeId);
    if (sampleData) {
      // Revoke the blob URL to free memory
      URL.revokeObjectURL(sampleData.blobUrl);
      this.sampleBank.delete(genomeId);
      
      // Update Strudel sample bank
      this.updateStrudelSampleBank();
      
      console.log(`LiveCodingUnit ${this.id}: Removed sample for genome ${genomeId}`);
    }
  }

  /**
   * Clear all samples from the bank
   */
  clearSampleBank() {
    // Revoke all blob URLs
    this.sampleBank.forEach((sampleData) => {
      URL.revokeObjectURL(sampleData.blobUrl);
    });
    
    this.sampleBank.clear();
    this.blobUrlCache.clear();
  this._registeredSamples = new Set();
    this.sampleCounter = 0;
    
    console.log(`LiveCodingUnit ${this.id}: Sample bank cleared`);
  }

  /**
   * Debug method to check unit isolation
   * @returns {Object} - Debug information about this unit's state
   */
  getIsolationDebugInfo() {
    const contextSamples = this.replInstance?.context?._samples || {};
    const registeredSamples = Array.from(this._registeredSamples || []);
    const globalInstanceKey = `strudelInstance_${this.id}`;
    const hasPersistentInstance = !!window[globalInstanceKey];
    
    return {
      unitId: this.id,
      hasReplInstance: !!this.replInstance,
      hasEditorInstance: !!this.editorInstance,
      hasStrudelElement: !!this.strudelElement,
      hasPersistentInstance,
      sampleBankSize: this.sampleBank.size,
      sampleNames: Array.from(this.sampleBank.values()).map(s => s.name),
      registeredSamples: registeredSamples,
      contextSamples: Object.keys(contextSamples),
      contextSamplesCount: Object.keys(contextSamples).length,
      currentCode: this.currentCode,
      hasPendingSamples: this.hasPendingSamples,
      pendingSamplesCount: Object.keys(this.pendingSamples || {}).length,
      hasPendingCode: !!this.pendingCode,
      hasRetryLoop: !!this._retryInterval,
      isReadyForSounds: this.isReadyForSounds(),
      isPlaying: this.isPlaying,
      globalUpdateMethod: `updateUnit${this.id}` in window,
      lastRegistrationAt: this._lastRegistrationAt || 'never',
      replContextType: typeof this.replInstance?.context
    };
  }

  /**
   * Get current code from CodeMirror editor
   */
  getCurrentCode() {
    console.log('🔍 getCurrentCode() trying different methods...');
    
    // Method 1: Try CodeMirror directly from strudel element
    if (this.strudelElement) {
      const cmElement = this.strudelElement.querySelector('.CodeMirror');
      if (cmElement && cmElement.CodeMirror && typeof cmElement.CodeMirror.getValue === 'function') {
        const code = cmElement.CodeMirror.getValue();
        console.log('🔍 Got code from CodeMirror:', code);
        return code;
      }
    }
    
    // Method 2: Try editor instance CodeMirror
    if (this.editorInstance && this.editorInstance.cm && typeof this.editorInstance.cm.getValue === 'function') {
      const code = this.editorInstance.cm.getValue();
      console.log('🔍 Got code from editorInstance.cm:', code);
      return code;
    }
    
    // Method 3: Try strudel element's editor property
    if (this.strudelElement && this.strudelElement.editor) {
      const editor = this.strudelElement.editor;
      if (editor.cm && typeof editor.cm.getValue === 'function') {
        const code = editor.cm.getValue();
        console.log('🔍 Got code from strudelElement.editor.cm:', code);
        return code;
      }
      if (typeof editor.getCode === 'function') {
        const code = editor.getCode();
        console.log('🔍 Got code from strudelElement.editor.getCode():', code);
        return code;
      }
      if (editor.code !== undefined) {
        const code = editor.code;
        console.log('🔍 Got code from strudelElement.editor.code:', code);
        return code;
      }
    }
    
    // Method 4: Try the strudel element's code attribute
    if (this.strudelElement && this.strudelElement.getAttribute) {
      const code = this.strudelElement.getAttribute('code');
      if (code) {
        console.log('🔍 Got code from strudelElement.getAttribute("code"):', code);
        return code;
      }
    }
    
    // Method 5: Try the strudel element's value property
    if (this.strudelElement && this.strudelElement.value) {
      const code = this.strudelElement.value;
      console.log('🔍 Got code from strudelElement.value:', code);
      return code;
    }
    
    // Last resort: use stored code or base pattern
    const fallbackCode = this.currentCode || this.basePattern;
    console.log('🔍 Using fallback code:', fallbackCode);
    return fallbackCode;
  }

  /**
   * Cleanup resources
   */
  cleanup() {
    console.log(`LiveCodingUnit ${this.id}: Starting cleanup`);
    
    // Persist current code before cleanup
    try {
      this.persistCurrentCode();
    } catch (err) {
      console.warn(`LiveCodingUnit ${this.id}: Error persisting code during cleanup:`, err);
    }
    
    // Clear timeout
    if (this._persistTimeout) {
      clearTimeout(this._persistTimeout);
      this._persistTimeout = null;
    }
    
    // Clear retry interval
    if (this._retryInterval) {
      clearInterval(this._retryInterval);
      this._retryInterval = null;
    }
    
    // Remove event listeners
    if (this.strudelElement) {
      if (this._blurListener) {
        this.strudelElement.removeEventListener('blur', this._blurListener);
        this._blurListener = null;
      }
      if (this._inputListener) {
        this.strudelElement.removeEventListener('input', this._inputListener);
        this._inputListener = null;
      }
    }
    
    // Stop playback
    try {
      this.stop();
    } catch (err) {
      console.warn(`LiveCodingUnit ${this.id}: Error stopping playback during cleanup:`, err);
    }
    
    // Clear sample bank (this will revoke blob URLs)
    this.clearSampleBank();
    
    // Unregister from global registry
    this._unregisterGlobally();
    
    // Clear REPL instance references
    this.replInstance = null;
    this.editorInstance = null;
    this.strudelElement = null;
    
    // Clear pending items
    this.pendingSamples = {};
    this.hasPendingSamples = false;
    this.pendingCode = null;
    
    // Clean up global update method and persistent REPL instance
    delete window[`updateUnit${this.id}`];
    
    // Clean up persistent REPL instance
    const globalInstanceKey = `strudelInstance_${this.id}`;
    if (window[globalInstanceKey]) {
      console.log(`LiveCodingUnit ${this.id}: Cleaning up persistent REPL instance`);
      try {
        const element = window[globalInstanceKey];
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
        }
      } catch (err) {
        console.warn(`LiveCodingUnit ${this.id}: Error removing persistent REPL element:`, err);
      }
      delete window[globalInstanceKey];
    }
    
    // Call parent cleanup
    super.cleanup();
    
    console.log(`LiveCodingUnit ${this.id}: Cleanup completed`);
  }
}
